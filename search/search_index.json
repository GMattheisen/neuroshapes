{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/docs/data-models/brainatlas/brain-atlas-derivation.html","text":"","title":"Brain Atlas Derivation"},{"location":"/docs/data-models/brainatlas/brain-atlas-derivation.html#brain-atlas-derivation","text":"","title":"Brain Atlas Derivation"},{"location":"/docs/data-models/brainatlas/brain-atlas-derivation.html#use-case","text":"","title":"Use case"},{"location":"/docs/data-models/brainatlas/brain-atlas-derivation.html#description","text":"TBD","title":"Description"},{"location":"/docs/data-models/brainatlas/brain-atlas-derivation.html#competency-questions","text":"TBD","title":"Competency questions"},{"location":"/docs/data-models/brainatlas/brain-atlas-derivation.html#provenance-pattern","text":"Link towards the provenance pattern: TBD","title":"Provenance pattern"},{"location":"/docs/data-models/brainatlas/brain-atlas-derivation.html#entities","text":"The different entity types involved are described below.\nType Description An Entity type A description","title":"Entities"},{"location":"/docs/data-models/brainatlas/brain-atlas-derivation.html#activities","text":"Type Description An activity Type A description","title":"Activities"},{"location":"/docs/data-models/brainatlas/brain-atlas-derivation.html#agents","text":"Type Description An Agent Types A description","title":"Agents"},{"location":"/docs/index.html","text":"","title":"Neuroshapes"},{"location":"/docs/index.html#neuroshapes","text":"","title":"Neuroshapes"},{"location":"/docs/index.html#why-neuroshapes-","text":"The goal of Neuroshapes is the development of open, use case driven and shared validatable data models (schemas, vocabularies) to enable the FAIR principles (Findable, Accessible, Interoperable and Reusable) for basic, computational and clinical neuroscience (meta)data. The data models developed thus far entities for electrophysiology, neuron morphology, brain atlases, in vitro electrophysiology and computational modeling. Future developments could include brain imaging, transcriptomic and clinical form data, as determined by community interests.\nNote All data models presented in this documentation are still drafts. Potential changes can be discussed on Github or on Gitter","title":"Why Neuroshapes ?"},{"location":"/docs/index.html#neuroshapes-goals","text":"the use of standard semantic markups and linked data principles as ways to structure metadata and related data: the W3C RDF format is leveraged, specifically its developer-friendly JSON-LD serialization. The adoption of linked data principles and JSON-LD will ease federated access and discoverability of distributed neuroscience (meta)data over the web. the use of the W3C SHACL (Shapes Constraint Language) recommendation as a rich metadata schema language which is formal and expressive; interoperable; machine-readable; and domain-agnostic. With SHACL, (meta)data quality can be enforced based on schemas and vocabularies (easily discoverable and searchable) rather than being fully encoded in procedural codes. SHACL also provides key interoperability capabilities to ensure the evolution of standard data models and data longevity. It allows to incrementally build standard data models in terms of semantics and sophistication. the reuse of existing schemas and semantic markups (like schema.org ) and existing ontologies and controlled vocabularies (including NIFSTD - NIF Standard Ontologies) the use of the W3C PROV-O recommendation as a format to record (meta)data provenance: a SHACL version of the W3C PROV-O is created.","title":"Neuroshapes Goals"},{"location":"/docs/index.html#get-involved","text":"Join the INCF Special Interest Group on Neuroshapes Read the How to contribute section","title":"Get involved"},{"location":"/docs/gettingstarted/index.html","text":"","title":"Getting Started"},{"location":"/docs/gettingstarted/index.html#getting-started","text":"","title":"Getting Started"},{"location":"/docs/gettingstarted/overview.html","text":"","title":"Overview"},{"location":"/docs/gettingstarted/overview.html#overview","text":"A draft for a standardized description of data provenance for the following domains:\nData models Brain Atlas Electrophysiology Morphology\nNote All data models presented in this documentation are still drafts. Potential changes can be discussed on Github or on Gitter","title":"Overview"},{"location":"/docs/gettingstarted/download.html","text":"","title":"Download"},{"location":"/docs/gettingstarted/download.html#download","text":"Neuroshapes schemas are tested using a shacl workbench which is a SBT plugin that helps in the development of SHACL schemas in JSON-LD format. Please follow these steps to run the tests and download the schemas:\nInstall sbt Clone the INCF/neuroshapes repository and run the tests\n# Go to home\ncd  ~\n\n# Clone the repository\ngit clone https://github.com/INCF/neuroshapes.git\n\ncd neuroshapes\n\n# Run 'sbt'\nsbt\n\n# Run 'test'\ntest\n\n# Export all the locally defined schemas to the dir /tmp/my-schemas using <http://localhost:8080/v0> as base uri \nexportSchemas http://localhost:8080/v0 /tmp/my-schemas\n\n# Schemas can be defined in modules that are imported by local modules. The collectResources command can be run to collect all schemas and contexts defined in this project classpath\n\n## Collect schemas\ncollectResources http://localhost:8080/v1 /tmp/my-schemas schemas\n\n## Collect everything defined\ncollectResources http://localhost:8080/v1 /tmp/my-schemas all","title":"Download"},{"location":"/docs/gettingstarted/contribution.html","text":"","title":"How to contribute"},{"location":"/docs/gettingstarted/contribution.html#how-to-contribute","text":"We would love for you to contribute to the Neuroshapes familly of data models and help make them even better than they are now! As a contributor, find in the next sections the guidelines we would like you to follow.","title":"How to contribute"},{"location":"/docs/gettingstarted/contribution.html#got-a-question-or-a-problem-","text":"Please do not hesitate to open an issue here and join the INCF neuroshapes SIG at INCF Special Interest Group on Neuroshapes.","title":"Got a Question or a Problem?"},{"location":"/docs/gettingstarted/contribution.html#found-a-bug-","text":"If you find a bug in the source code of any tools, in any schema or vocabulary in this repository, you can help us fix it by submitting an issue to our GitHub Repository. Even better, you can submit a Pull Request with a fix.","title":"Found a Bug?"},{"location":"/docs/gettingstarted/contribution.html#missing-a-feature-or-a-data-model-","text":"You can request them by submitting an issue to our GitHub Repository. If you would like to implement a new feature or propose a new data model specification, please submit an issue with a proposal for your work first, to be sure it can be implemented and most importantly, to trigger discussions and enable collaborations with interested people. Please consider what kind of change it is:\nFor a Data Model Specification Proposal or Extension, first open an issue and outline your proposal so that it can be discussed. Data examples implementing/illustrating an existing Data Model can be directly submitted as a Pull Request. For example different atlas releases conformant to the atlas registration prov pattern can be submitted. For a Major Feature related to the tools and scripts made available in this repository, first open an issue and outline your proposal so that it can be discussed. This will also allow us to better coordinate our efforts, prevent duplication of work, and help you to craft the change so that it is successfully accepted into the project. Small Features can be crafted and directly submitted as a Pull Request.","title":"Missing a Feature or a data model?"},{"location":"/docs/gettingstarted/contribution.html#submission-guidelines","text":"","title":"Submission Guidelines"},{"location":"/docs/gettingstarted/contribution.html#submitting-an-issue","text":"Before you submit an issue, please search the issue tracker, maybe an issue for your problem already exists and the discussion might inform you of workarounds readily available. We want to fix all the issues as soon as possible, but before fixing a bug we need to reproduce and confirm it. In order to reproduce bugs we will need as much information as possible, and preferably be in touch with you to gather information.","title":"Submitting an Issue"},{"location":"/docs/gettingstarted/contribution.html#submitting-a-data-model-specification","text":"Before you submit your proposal consider the following guidelines:\nPlease join the INCF Special Interest Group (SIG) on Neuroshapes before sending pull requests. Proposals are managed and reviewed by members of that INCF SIG. Open an issue and outline your proposal so that it can be discussed.","title":"Submitting a Data Model Specification"},{"location":"/docs/gettingstarted/contribution.html#submitting-a-pull-request-pr-","text":"Before you submit your Pull Request (PR) consider the following guidelines:\nPlease join the INCF SIG on Neuroshapes before sending Pull requests. Proposals are managed and reviewed by members of that INCF SIG. Clone the Neuroshapes github repository:\n# Go to home\n    cd  ~\n    \n    # Clone the repository\n    git clone https://github.com/INCF/neuroshapes.git\n    \n    cd neuroshapes\nMake your changes in a new git branch: shell git checkout -b my-fix-branch master Create your patch, including appropriate test cases. Run the full test suite, and ensure that all tests pass. # Run 'sbt'\nsbt\n\n# Run 'test'\ntest\n\n# Exit\nexit\n\n Commit your changes using a descriptive commit message. shell git commit -a Note: the optional commit -a command line option will automatically “add” and “rm” edited files. Push your branch to GitHub: git push origin my-fix-branch\n In GitHub, send a pull request to the master branch. If we suggest changes then: Make the required updates. Re-run the test suites to ensure tests are still passing. Rebase your branch and force push to your GitHub repository (this will update your Pull Request): git rebase master -i\ngit push -f\n That’s it! Thank you for your contribution! After your pull request is mergedAfter your pull request is merged, you can safely delete your branch and pull the changes from the main (upstream) repository: Delete the remote branch on GitHub either through the GitHub web UI or your local shell as follows: git push origin --delete my-fix-branch\n Check out the master branch: git checkout master -f\n Delete the local branch: git branch -D my-fix-branch\n Update your master with the latest upstream version: git pull --ff upstream master","title":"Submitting a Pull Request (PR)"},{"location":"/docs/gettingstarted/contribution.html#join-the-incf-neuroshape-sig","text":"Join the INCF Special Interest Group on Neuroshapes.","title":"Join the INCF Neuroshape SIG"},{"location":"/docs/datamodeling/index.html","text":"","title":"Modeling Your Data"},{"location":"/docs/datamodeling/index.html#modeling-your-data","text":"TBD","title":"Modeling Your Data"},{"location":"/docs/shacl-tutorial/overview/index.html","text":"","title":"SHACL In a Nutshell"},{"location":"/docs/shacl-tutorial/overview/index.html#shacl-in-a-nutshell","text":"Please find below some resources as well as useful links for building data models involving SHACL shapes:\nThe W3C SHACL specification Useful resources when learning SHACL SHACL reference book, tutorials and playground http://www.validatingrdf.com/ SHACL playground: http://shacl.org/playground/ Topquadrant SHACL tutorial Useful resources when learning JSON-LD https://json-ld.org Json-ld API best practicies Ontology/SHACL editor TopBraid Composer Free Edition SHACL validator SHACLEX: scala based pySHACL: python based TopQuadrant/shacl: JAVA based","title":"SHACL In a Nutshell"},{"location":"/docs/data-models/index.html","text":"","title":"Data Model Specifications"},{"location":"/docs/data-models/index.html#data-model-specifications","text":"","title":"Data Model Specifications"},{"location":"/docs/data-models/index.html#overview","text":"This section describes key scientific and technical activities and agents involved in the generation of various neuroscience data types (basic, computational and clinical neuroscience data). For each data types, the generation context is described by mean of a data provenance pattern which is implemented as a set of W3C SHACL based validatable schemas.\nBrain Atlas Electrophysiology Morphology","title":"Overview"},{"location":"/docs/data-models/brainatlas/brain-atlas.html","text":"","title":"Brain Atlas"},{"location":"/docs/data-models/brainatlas/brain-atlas.html#brain-atlas","text":"In this section we describe data models that represent the use of brain atlases.","title":"Brain Atlas"},{"location":"/docs/data-models/brainatlas/brain-atlas.html#use-cases","text":"List of use cases:\nRegistering a brain atlas Registering a whole brain morphology into an atlas","title":"Use cases"},{"location":"/docs/data-models/brainatlas/registering-brain-atlas.html","text":"","title":"Registering a Brain Atlas"},{"location":"/docs/data-models/brainatlas/registering-brain-atlas.html#registering-a-brain-atlas","text":"","title":"Registering a Brain Atlas"},{"location":"/docs/data-models/brainatlas/registering-brain-atlas.html#use-case","text":"","title":"Use case"},{"location":"/docs/data-models/brainatlas/registering-brain-atlas.html#description","text":"This specification describes the process of register a brain atlas. The process starts with a subject collection which are imaged and processed to generate 3 derived entities: a template image data, a parcellation image data, as well as brain parcellation labels. The first 2 entities are further transformed into volumetric representation, from which an atlas spatial reference system is derived. The parcellation labels are converted into ontology. The final template volume, parcellation volume, parcellation ontology as well as the atlas spatial reference system are used to form an atlas release.","title":"Description"},{"location":"/docs/data-models/brainatlas/registering-brain-atlas.html#supported-data-queries","text":"From a specific version of a brain atlas:\nGet the brain parcellation dataset Get the brain parcellation labels dataset Get the image stack datasets Get the coordinate system of the atlas spatial reference system","title":"Supported Data Queries"},{"location":"/docs/data-models/brainatlas/registering-brain-atlas.html#data-provenance-pattern","text":"","title":"Data Provenance pattern"},{"location":"/docs/data-models/brainatlas/registering-brain-atlas.html#schemas","text":"","title":"Schemas"},{"location":"/docs/data-models/brainatlas/registering-brain-atlas.html#entities","text":"The different entity types involved are described below.\nType Description SubjectCollection A collection of subject to be used in the experiment TemplateImageData Template image data acquired and processed from the subject collection ParcellationImageData Parcellation image data generated from the template image data ParcellationLabel Parcellation labels correspond to the annotations in the parcellation image TemplateVolume Template volume generated from the template image data ParcellationVolume Parcellation volume generated from the parcellation image data ParcellationOntology Parcellation ontology converted from the parcellation label AtlasSpatialReferenceSystem The spatial coordinate system of the atlas space AtlasRelease An atlas release comprises template volume, parcellation volume, parcellation ontology as well as the atlas spatial reference system Protocol Protocol that describes the method used in the design and execution of the experiment","title":"Entities"},{"location":"/docs/data-models/brainatlas/registering-brain-atlas.html#activities","text":"Type Description Atlas Construction Process to construct a brain atlas Template Reconstruction Reconstruct the template image data into volumetric representation Parcellation Reconstruction Reconstruct the parcellation image data into volumetric representation Ontology Conversion Convert the parcellation label into ontological representation","title":"Activities"},{"location":"/docs/data-models/brainatlas/registering-brain-atlas.html#agents","text":"Type Description Person Person associated with an activity SoftwareAgent Software associated with an activity Organization Organization associated with an activity","title":"Agents"},{"location":"/docs/data-models/brainatlas/registering-brain-atlas.html#contributors","text":"Huanxiang Lu Anna-Kristin Kaufmann Silvia Jimenez Sy Mohameth Francois Samuel Kerrien Sean Hill","title":"Contributors"},{"location":"/docs/data-models/brainatlas/registering-whole-brain-morphology.html","text":"","title":"Registering a Whole Brain Morphology in an Atlas"},{"location":"/docs/data-models/brainatlas/registering-whole-brain-morphology.html#registering-a-whole-brain-morphology-in-an-atlas","text":"","title":"Registering a Whole Brain Morphology in an Atlas"},{"location":"/docs/data-models/brainatlas/registering-whole-brain-morphology.html#use-case","text":"","title":"Use case"},{"location":"/docs/data-models/brainatlas/registering-whole-brain-morphology.html#description","text":"This specification describes the process of register a whole brain morphology into an atlas. The process starts with reconstruction the whole brain morphologies from image stack. The image stack is used to register to the reference atlas, resulting in a transformation. This transformation is then used to transform the reconstructed whole brain cell into the reference atlas space.","title":"Description"},{"location":"/docs/data-models/brainatlas/registering-whole-brain-morphology.html#supported-data-queries","text":"Get the whole brain morphology from a given atlas spatial reference system. Get the whole brain morphologies derived from a image stack","title":"Supported Data Queries"},{"location":"/docs/data-models/brainatlas/registering-whole-brain-morphology.html#data-provenance-pattern","text":"","title":"Data Provenance pattern"},{"location":"/docs/data-models/brainatlas/registering-whole-brain-morphology.html#schemas","text":"","title":"Schemas"},{"location":"/docs/data-models/brainatlas/registering-whole-brain-morphology.html#entities","text":"The different entity types involved are described below.\nType Description Subject Subject that was used in the experiment TemplateVolume Template volume generated from the template image data AtlasSpatialReferenceSystem The spatial coordinate system of the atlas space ImageStack Image stack obtained from the brain tissue of the subject ReconstructedCell Reconstructed cell Transform A linear or non-linear transform Protocol Protocol that describes the method used in the design and execution of the experiment","title":"Entities"},{"location":"/docs/data-models/brainatlas/registering-whole-brain-morphology.html#activities","text":"Type Description BrainImaging Technique used to obtain an image stack of the brain tissue containing the cells for reconstruction ReconstructionFromImage Technique used to reconstruct the stained cell Transformation Transform a geometric object","title":"Activities"},{"location":"/docs/data-models/brainatlas/registering-whole-brain-morphology.html#agents","text":"Type Description Person Person associated with an activity SoftwareAgent Software associated with an activity Organization Organization associated with an activity","title":"Agents"},{"location":"/docs/data-models/brainatlas/registering-whole-brain-morphology.html#contributors","text":"Huanxiang Lu Anna-Kristin Kaufmann Silvia Jimenez Sy Mohameth Francois Samuel Kerrien Sean Hill","title":"Contributors"},{"location":"/docs/data-models/electrophysiology/electrophysiology.html","text":"","title":"Electrophysiology"},{"location":"/docs/data-models/electrophysiology/electrophysiology.html#electrophysiology","text":"In Neuroscience, electrophysiology refers to the study of the electrical activity of neurons, e.g. by measuring action potential activity. In this section, we describe data models that represent the generation context of the following neuroscience data types:","title":"Electrophysiology"},{"location":"/docs/data-models/electrophysiology/electrophysiology.html#intracellular-recording","text":"Note In Vitro Whole Cell Patch Clamp Recording In Vitro IntraCellular Sharp Electrode Recording","title":"Intracellular Recording"},{"location":"/docs/data-models/electrophysiology/wholecellpatchclamp-recording.html","text":"","title":"In Vitro Whole Cell Patch Clamp Recording"},{"location":"/docs/data-models/electrophysiology/wholecellpatchclamp-recording.html#in-vitro-whole-cell-patch-clamp-recording","text":"","title":"In Vitro Whole Cell Patch Clamp Recording"},{"location":"/docs/data-models/electrophysiology/wholecellpatchclamp-recording.html#use-case","text":"","title":"Use case"},{"location":"/docs/data-models/electrophysiology/wholecellpatchclamp-recording.html#description","text":"This specification describes the metadata collected for in vitro intracellular electrophysiology recordings using the whole cell patch clamp configuration. Whole cell patch clamp is a type of electrophysiological recording used to measure ionic currents over the membrane of an entire cell. Suction is applied to rupture the cell membrane which provides access to the intracellular space of the patched cell. Metadata is collected on the subject used in the experiment, the slice, the patched cell which was recorded as well as the recording traces and protocols. Additionally, metadata for the brain slicing, the whole cell patch clamp and the stimulus (including protocols and agents) involved in the generation of the recording traces are captured.","title":"Description"},{"location":"/docs/data-models/electrophysiology/wholecellpatchclamp-recording.html#supported-data-queries","text":"The following points describe an example subset of questions supported by the data provenance pattern:\nRetrieve all recording traces generated from rat somatosensory cortex using selected stimuli. Retrieve recording traces by recording day and experimenter. Retrieve all response traces from a specific patched cell. Get the holding potential for an individual recording trace.","title":"Supported Data Queries"},{"location":"/docs/data-models/electrophysiology/wholecellpatchclamp-recording.html#data-provenance-pattern","text":"","title":"Data Provenance pattern"},{"location":"/docs/data-models/electrophysiology/wholecellpatchclamp-recording.html#schemas","text":"","title":"Schemas"},{"location":"/docs/data-models/electrophysiology/wholecellpatchclamp-recording.html#entities","text":"The different entity types involved in the experiment are listed below.\nType Description Subject Subject that was used in the experiment Slice Brain slice obtained from the subject PatchedSlice Brain slice containing patched cells PatchedCellCollection Collection of patched cells in a single slice (e.g. for multi-patch recordings) PatchedCell Cell that was patched in the slice Trace Individual recording trace of the patched cell (stimulation/input and response/output trace) Protocol Protocol that describes the method used in the design and execution of the experiment","title":"Entities"},{"location":"/docs/data-models/electrophysiology/wholecellpatchclamp-recording.html#activities","text":"The different activity types involved in the experiment are listed below.\nType Description BrainSlicing Technique used to obtain a brain slice for patching WholeCellPatchClamp Technique used to study electrical activity of individual living cells StimulusExperiment Technique used to obtain the electrical signature of cells through injection of a defined current pattern","title":"Activities"},{"location":"/docs/data-models/electrophysiology/wholecellpatchclamp-recording.html#agents","text":"The different agent types involved in the experiment are listed below.\nType Description Person Person associated with an activity SoftwareAgent Software associated with an activity Organization Organization associated with an activity","title":"Agents"},{"location":"/docs/data-models/electrophysiology/wholecellpatchclamp-recording.html#contributors","text":"Anna-Kristin Kaufmann Huanxiang Lu Silvia Jimenez Rodrigo Perin Sy Mohameth Francois Samuel Kerrien Sean Hill","title":"Contributors"},{"location":"/docs/data-models/electrophysiology/intracellularsharpelectrode-recording.html","text":"","title":"In Vitro IntraCellular Sharp Electrode Recording"},{"location":"/docs/data-models/electrophysiology/intracellularsharpelectrode-recording.html#in-vitro-intracellular-sharp-electrode-recording","text":"","title":"In Vitro IntraCellular Sharp Electrode Recording"},{"location":"/docs/data-models/electrophysiology/intracellularsharpelectrode-recording.html#use-case","text":"","title":"Use case"},{"location":"/docs/data-models/electrophysiology/intracellularsharpelectrode-recording.html#description","text":"This specification describes the metadata collected for in vitro intracellular electrophysiology recordings using intracellular sharp electrodes configuration. Metadata is collected on the subject used in the experiment, the slice, the cell which was recorded as well as the recording traces and protocols. Additionally, metadata for the brain slicing, the intracellular sharp electrodes and the stimulus (including protocols and agents) involved in the generation of the recording traces are captured.","title":"Description"},{"location":"/docs/data-models/electrophysiology/intracellularsharpelectrode-recording.html#supported-data-queries","text":"The following points describe an example subset of questions supported by the data provenance pattern:\nRetrieve all recording traces generated from rat somatosensory cortex using selected stimuli. Retrieve recording traces by recording day and experimenter. Retrieve all response traces from a specific recorded cell.","title":"Supported Data Queries"},{"location":"/docs/data-models/electrophysiology/intracellularsharpelectrode-recording.html#data-provenance-pattern","text":"","title":"Data Provenance pattern"},{"location":"/docs/data-models/electrophysiology/intracellularsharpelectrode-recording.html#schemas","text":"","title":"Schemas"},{"location":"/docs/data-models/electrophysiology/intracellularsharpelectrode-recording.html#entities","text":"The different entity types involved in the experiment are listed below.\nType Description Subject Subject that was used in the experiment Slice Brain slice obtained from the subject IntraCellularSharpElectrodeRecordedSlice Brain slice containing recorded cells IntraSharpRecordedCellCollection Collection of recorded cells in a single slice IntraCellularSharpElectrodeRecordedCell Cell that was recorded in the slice Trace Individual recording trace of the cell (stimulation/input and response/output trace) Protocol Protocol that describes the method used in the design and execution of the experiment","title":"Entities"},{"location":"/docs/data-models/electrophysiology/intracellularsharpelectrode-recording.html#activities","text":"The different activity types involved in the experiment are listed below.\nType Description BrainSlicing Technique used to obtain a brain slice IntraCellularSharpElectrode Technique used to study electrical activity of individual living cells StimulusExperiment Technique used to obtain the electrical signature of cells through injection of a defined current pattern","title":"Activities"},{"location":"/docs/data-models/electrophysiology/intracellularsharpelectrode-recording.html#agents","text":"The different agent types involved in the experiment are listed below.\nType Description Person Person associated with an activity SoftwareAgent Software associated with an activity Organization Organization associated with an activity","title":"Agents"},{"location":"/docs/data-models/electrophysiology/intracellularsharpelectrode-recording.html#contributors","text":"Andrew Davison Anna-Kristin Kaufmann Huanxiang Lu Silvia Jimenez Sy Mohameth Francois Samuel Kerrien Sean Hill","title":"Contributors"},{"location":"/docs/data-models/morphology/morphology.html","text":"","title":"Neuron Morphology"},{"location":"/docs/data-models/morphology/morphology.html#neuron-morphology","text":"Note In this section we describe data models that represent the generation context of the following neuron morphology data types: In Vitro Slice Neuron Morphology Reconstruction Whole Brain Neuron Morphology Reconstruction","title":"Neuron Morphology"},{"location":"/docs/data-models/morphology/morphology-reconstruction.html","text":"","title":"In Vitro Slice Neuron Morphology Reconstruction"},{"location":"/docs/data-models/morphology/morphology-reconstruction.html#in-vitro-slice-neuron-morphology-reconstruction","text":"","title":"In Vitro Slice Neuron Morphology Reconstruction"},{"location":"/docs/data-models/morphology/morphology-reconstruction.html#use-case","text":"","title":"Use case"},{"location":"/docs/data-models/morphology/morphology-reconstruction.html#description","text":"This specification describes metadata collected for morphology reconstructions from brain slices. Reconstruction of a neuron morphology from slice typically follows the injection of a dye during a whole cell patch clamp recording. Some of the activities and entities shown here are hence shared with the in vitro whole cell patch clamp recording. Metadata is collected on the subject used in the experiment, the slice containing the cell, the labeled cell and the reconstructed neuron morphology. The dye-filled neuron is most commonly visualized using a histological technique following the fixation of the brain tissue. The stained cells are annotated and then reconstructed. Metadata from all these procedures is captured as well as the protocols used and the persons, software and organizations involved in each of the steps.","title":"Description"},{"location":"/docs/data-models/morphology/morphology-reconstruction.html#supported-data-queries","text":"The following points describe an example subset of questions supported by the data provenance pattern:\nRetrieve morphology reconstructions from a given brain region. Retrieve pyramidal cell reconstructions. Retrieve morphology reconstructions from a specific experimenter. Retrieve morphology reconstructions from a subject of a given age and sex. Retrieve morphology reconstructions which were reconstructed in a given year","title":"Supported Data Queries"},{"location":"/docs/data-models/morphology/morphology-reconstruction.html#data-provenance-pattern","text":"","title":"Data Provenance pattern"},{"location":"/docs/data-models/morphology/morphology-reconstruction.html#schemas","text":"","title":"Schemas"},{"location":"/docs/data-models/morphology/morphology-reconstruction.html#entities","text":"The different entity types involved in the experiment are listed below.\nType Description Subject Subject that was used in the experiment Slice Brain slice obtained from the subject PatchedSlice Brain slice containing patched cells PatchedCellCollection Collection of patched cells in a single slice (e.g. for multi-patch recordings) PatchedCell Cell that was patched in the slice FixedStainedSlice Brain slice after fixation and staining AnnotatedSlice Brain slice containing the identified and annotated stained cells LabeledCellCollection Collection of labeled cells in a single slice LabeledCell Cell that was labeled in the slice ReconstructedCell Reconstructed cell Protocol Protocol that describes the method used in the design and execution of the experiment","title":"Entities"},{"location":"/docs/data-models/morphology/morphology-reconstruction.html#activities","text":"The different activity types involved in the experiment are listed below.\nType Description BrainSlicing Technique used to obtain a brain slice for patching WholeCellPatchClamp Technique used to study electrical activity of individual living cells FixationStainingMounting Technique used to fix and stain the slice AcquisitionAnnotation Technique used to acquire an image of the slice and annotate the stained cells Reconstruction Technique used to reconstruct the stained cell","title":"Activities"},{"location":"/docs/data-models/morphology/morphology-reconstruction.html#agents","text":"The different agent types involved in the experiment are listed below.\nType Description Person Person associated with an activity SoftwareAgent Software associated with an activity Organization Organization associated with an activity","title":"Agents"},{"location":"/docs/data-models/morphology/morphology-reconstruction.html#contributors","text":"Anna-Kristin Kaufmann Huanxiang Lu Silvia Jimenez Rodrigo Perin Sy Mohameth Francois Samuel Kerrien Sean Hill","title":"Contributors"},{"location":"/docs/data-models/morphology/whole-brain-neuron-morphology-reconstruction.html","text":"","title":"Whole Brain Neuron Morphology Reconstruction"},{"location":"/docs/data-models/morphology/whole-brain-neuron-morphology-reconstruction.html#whole-brain-neuron-morphology-reconstruction","text":"","title":"Whole Brain Neuron Morphology Reconstruction"},{"location":"/docs/data-models/morphology/whole-brain-neuron-morphology-reconstruction.html#use-case","text":"","title":"Use case"},{"location":"/docs/data-models/morphology/whole-brain-neuron-morphology-reconstruction.html#description","text":"This specification describes metadata collected for whole brain morphology reconstructions from a continuous whole brain image stack. Reconstruction of a neuron morphology from an image stack is typically enabled through sparse neuronal labeling following e.g. viral delivery of a fluorescent protein. Metadata is collected on the subject used in the experiment, the image stack containing the labeled cells and the reconstructed neuron morphology. Additionally, metadata for the brain imaging and the reconstruction from image (including protocols and agents) are captured.","title":"Description"},{"location":"/docs/data-models/morphology/whole-brain-neuron-morphology-reconstruction.html#supported-data-queries","text":"The following points describe an example subset of questions supported by the data provenance pattern:\nRetrieve morphology reconstructions from a given brain region. Retrieve pyramidal cell reconstructions. Retrieve morphology reconstructions projecting to a given brain region. Retrieve morphology reconstructions from a subject of a given age and sex. Retrieve morphology reconstructions which were reconstructed by a specific person.","title":"Supported Data Queries"},{"location":"/docs/data-models/morphology/whole-brain-neuron-morphology-reconstruction.html#data-provenance-pattern","text":"","title":"Data Provenance pattern"},{"location":"/docs/data-models/morphology/whole-brain-neuron-morphology-reconstruction.html#schemas","text":"","title":"Schemas"},{"location":"/docs/data-models/morphology/whole-brain-neuron-morphology-reconstruction.html#entities","text":"The different entity types involved in the experiment are listed below.\nType Description Subject Subject that was used in the experiment ImageStack Image stack obtained from the brain tissue of the subject ReconstructedCell Reconstructed cell Protocol Protocol that describes the method used in the design and execution of the experiment","title":"Entities"},{"location":"/docs/data-models/morphology/whole-brain-neuron-morphology-reconstruction.html#activities","text":"The different activity types involved in the experiment are listed below.\nType Description BrainImaging Technique used to obtain an image stack of the brain tissue containing the cells for reconstruction ReconstructionFromImage Technique used to reconstruct the stained cell","title":"Activities"},{"location":"/docs/data-models/morphology/whole-brain-neuron-morphology-reconstruction.html#agents","text":"The different agent types involved in the experiment are listed below.\nType Description Person Person associated with an activity SoftwareAgent Software associated with an activity Organization Organization associated with an activity","title":"Agents"},{"location":"/docs/data-models/morphology/whole-brain-neuron-morphology-reconstruction.html#contributors","text":"Anna-Kristin Kaufmann Huanxiang Lu Silvia Jimenez Rodrigo Perin Sy Mohameth Francois Samuel Kerrien Sean Hill","title":"Contributors"},{"location":"/docs/meetings.html","text":"","title":"Meetings and Workshops"},{"location":"/docs/meetings.html#meetings-and-workshops","text":"","title":"Meetings and Workshops"},{"location":"/docs/meetings.html#up-coming-meetings","text":"TBD","title":"Up coming meetings"},{"location":"/docs/meetings.html#past-meetings","text":"","title":"Past meetings"},{"location":"/docs/meetings.html#incf-neuroinformatics-2018-montreal","text":"This meeting was organised 8th of August during the Brainhack hackathon organised the day before the INCF Neuroinformatics 2018 conference. It was the first one for the INCF Neuroshapes Special Interest Group. The goal was mainly to present Neuroshapes motivation to the Neuroscience community at INCF NI2018 but also to connect with other data sharing and open science initiatives like NIDM to see if they can adopt Neuroshapes’ approach in term of data modelling. Participants showed interest in using the W3C SHACL specification, as a way to complement existing data models with data validation capability. They showed interest in the ability to describe what are the expected properties of a dataset by mean of schemas using json-ld (semantic markups) and W3C SHACL.\nNote Read the full meeting report here.","title":"INCF Neuroinformatics 2018, Montreal"},{"location":"/docs/license.html","text":"","title":"License"},{"location":"/docs/license.html#license","text":"Note All Neuroshapes data models and example data are licensed under CC-BY-4.0.","title":"License"},{"location":"/docs/contact.html","text":"","title":"Contact"},{"location":"/docs/contact.html#contact","text":"Note Contact the INCF Special Interest Group on Neuroshapes.","title":"Contact"},{"location":"/assets/contexts/nexus/core/shacl20170720/prefixmapings.html","text":"Prefix Name Namespace sh http://www.w3.org/ns/shacl# shsh http://www.w3.org/ns/shacl-shacl# rdf http://www.w3.org/1999/02/22-rdf-syntax-ns# rdfs http://www.w3.org/2000/01/rdf-schema# owl http://www.w3.org/2002/07/owl# xsd http://www.w3.org/2001/XMLSchema# prov http://www.w3.org/ns/prov# skos http://www.w3.org/2004/02/skos/core# schema http://schema.org/ nxv https://bbp-nexus.epfl.ch/vocabs/nexus/core/terms/v0.1.0/ nsg https://bbp-nexus.epfl.ch/vocabs/bbp/neurosciencegraph/core/v0.1.0/ ex http://example.org/","title":""},{"location":"/docs/index-claat.html","text":"","title":"Your First Progressive Web App"},{"location":"/docs/index-claat.html#your-first-progressive-web-app","text":"Codelab Feedback","title":"Your First Progressive Web App"},{"location":"/docs/index-claat.html#introduction","text":"Progressive Web Apps are experiences that combine the best of the web and the best of apps. They are useful to users from the very first visit in a browser tab, no install required. As the user progressively builds a relationship with the app over time, it becomes more and more powerful. It loads quickly, even on flaky networks, sends relevant push notifications, has an icon on the home screen, and loads as a top-level, full screen experience.","title":"Introduction"},{"location":"/docs/index-claat.html#","text":"A Progressive Web App is:\nProgressive - Works for every user, regardless of browser choice because it’s built with progressive enhancement as a core tenet. Responsive - Fits any form factor: desktop, mobile, tablet, or whatever is next. Connectivity independent - Enhanced with service workers to work offline or on low-quality networks. App-like - Feels like an app, because the app shell model separates the application functionality from application content . Fresh - Always up-to-date thanks to the service worker update process. Safe - Served via HTTPS to prevent snooping and to ensure content hasn’t been tampered with. Discoverable - Is identifiable as an “application” thanks to W3C manifest and service worker registration scope, allowing search engines to find it. Re-engageable - Makes re-engagement easy through features like push notifications. Installable - Allows users to add apps they find most useful to their home screen without the hassle of an app store. Linkable - Easily share the application via URL, does not require complex installation.\nThis codelab will walk you through creating your own Progressive Web App, including the design considerations, as well as implementation details, to ensure that your app meets the above key principles of a Progressive Web App.\nLooking for more? Check out the talks from the [2016 Progressive Web App Summit](https://www.youtube.com/playlist?list=PLNYkxOF6rcIAWWNR_Q6eLPhsyx6VvYjVb).","title":"What is a Progressive Web App?"},{"location":"/docs/index-claat.html#","text":"","title":"What you will build"},{"location":"/docs/index-claat.html#","text":"How to design and construct an app using the “app shell” method How to make your app work offline How to store data for later offline use","title":"What you’ll learn"},{"location":"/docs/index-claat.html#","text":"A recent version of Chrome. Note, this works in other browsers as well, but we’ll be using a few features of the Chrome DevTools to better understand what’s happening at the browser level. Web Server for Chrome, or your own web server of choice The sample code A text editor Basic knowledge of HTML, CSS, JavaScript, and Chrome DevTools\nThis codelab is focused on Progressive Web Apps. Non-relevant concepts and code blocks are glossed over and are provided for you to simply copy and paste.","title":"What you’ll need"},{"location":"/docs/index-claat.html#getting-set-up","text":"","title":"Getting set up"},{"location":"/docs/index-claat.html#","text":"Click the following link to download all the code for this codelab:\n[](https://github.com/googlecodelabs/your-first-pwapp/archive/master.zip)\nUnpack the downloaded zip file. This will unpack a root folder (your-first-pwapp-master), which contains one folder for each step of this codelab, along with all of the resources you will need.\nThe step-NN folders contain the desired end state of each step of this codelab. They are there for reference. We’ll be doing all our coding work in a directory called work.","title":"Download the Code"},{"location":"/docs/index-claat.html#","text":"While you’re free to use your own web server, this codelab is designed to work well with the Chrome Web Server. If you don’t have that app installed yet, you can install it from the Chrome Web Store.\n[](https://chrome.google.com/webstore/detail/web-server-for-chrome/ofhbbkphhbklhfoeikjpcbhemlocgigb)\nAfter installing the Web Server for Chrome app, click on the Apps shortcut on the bookmarks bar:\nMore help: [Add and open Chrome apps](https://support.google.com/chrome_webstore/answer/3060053)\nIn the ensuing window, click on the Web Server icon:\nYou’ll see this dialog next, which allows you to configure your local web server:\n<img src=“img/433870360ad308d4.png” alt=“Screen Shot 2016-02-18 at 11.48.14 AM.png” title=\"“Web Server for Chrome Screenshot”“ width=”513.64\" />\nClick the choose folder button, and select the work folder. This will enable you to serve your work in progress via the URL highlighted in the web server dialog (in the Web Server URL(s) section).\nUnder Options, check the box next to “Automatically show index.html”, as shown below:\nThen stop and restart the server by sliding the toggle labeled “Web Server: STARTED” to the left and then back to the right.\nNow visit your work site in your web browser (by clicking on the highlighted Web Server URL) and you should see a page that looks like this:\nThis app is not yet doing anything interesting - so far, it’s just a minimal skeleton with a spinner we’re using to verify your web server functionality. We’ll add functionality and UI features in subsequent steps.\nFrom this point forward, all testing/verification (e.g. the** Test It Out** sections in subsequent steps) should be performed using this web server setup.","title":"Install and verify web server"},{"location":"/docs/index-claat.html#architect-your-app-shell","text":"","title":"Architect your App Shell"},{"location":"/docs/index-claat.html#","text":"The app’s shell is the minimal HTML, CSS, and JavaScript that is required to power the user interface of a progressive web app and is one of the components that ensures reliably good performance. Its first load should be extremely quick and immediately cached. “Cached” means that the shell files are loaded once over the network and then saved to the local device. Every subsequent time that the user opens the app, the shell files are loaded from the local device’s cache, which results in blazing-fast startup times.\nApp shell architecture separates the core application infrastructure and UI from the data. All of the UI and infrastructure is cached locally using a service worker so that on subsequent loads, the Progressive Web App only needs to retrieve the necessary data, instead of having to load everything.\nA service worker is a script that your browser runs in the background, separate from a web page, opening the door to features that don’t need a web page or user interaction.\nPut another way, the app shell is similar to the bundle of code that you’d publish to an app store when building a native app. It is the core components necessary to get your app off the ground, but likely does not contain the data.","title":"What is the app shell?"},{"location":"/docs/index-claat.html#","text":"Using the app shell architecture allows you to focus on speed, giving your Progressive Web App similar properties to native apps: instant loading and regular updates, all without the need of an app store.","title":"Why use the App Shell architecture?"},{"location":"/docs/index-claat.html#","text":"The first step is to break the design down into its core components.\nAsk yourself:\nWhat needs to be on screen immediately? What other UI components are key to our app? What supporting resources are needed for the app shell? For example images, JavaScript, styles, etc.\nWe’re going to create a Weather app as our first Progressive Web App. The key components will consist of:\nWhen designing a more complex app, content that isn’t needed for the initial load can be requested later and then cached for future use. For example, we could defer the loading of the New City dialog until after we’ve rendered the first run experience and have some idle cycles available.","title":"**Design the App Shell **"},{"location":"/docs/index-claat.html#implement-your-app-shell","text":"There are multiple ways to get started with any project, in this case, to keep our project as simple as possible and concentrate on Progressive Web Apps, we’ve provided you with all of the resources you’ll need.","title":"Implement your App Shell"},{"location":"/docs/index-claat.html#","text":"Now we’ll add the core components we discussed in Architect the App Shell.\nRemember, the key components will consist of:\nHeader with a title, and add/refresh buttons Container for forecast cards A forecast card template A dialog for adding new cities A loading indicator\nThe index.html file that is already in your work directory should look something like this (this is a subset of the actual contents, don’t copy this code into your file):\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Weather PWA</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"styles/inline.css\">\n</head>\n<body>\n  <header class=\"header\">\n    <h1 class=\"header__title\">Weather PWA</h1>\n    <button id=\"butRefresh\" class=\"headerButton\"></button>\n    <button id=\"butAdd\" class=\"headerButton\"></button>\n  </header>\n\n  <main class=\"main\">\n    <div class=\"card cardTemplate weather-forecast\" hidden>\n    . . .\n    </div>\n  </main>\n\n  <div class=\"dialog-container\">\n  . . .\n  </div>\n\n  <div class=\"loader\">\n    <svg viewBox=\"0 0 32 32\" width=\"32\" height=\"32\">\n      <circle id=\"spinner\" cx=\"16\" cy=\"16\" r=\"14\" fill=\"none\"></circle>\n    </svg>\n  </div>\n\n  <!-- Insert link to app.js here -->\n</body>\n</html>\nNotice the loader is visible by default. This ensures that the user sees the loader immediately as the page loads, giving them a clear indication that the content is loading.\nTo save time, we’ve also already created the stylesheet for you to use.\nWe've given you the markup and styles to save you some time and make sure you're starting on a solid foundation. In the next section, you'll have an opportunity to write your own code.","title":"Create the HTML for the App Shell"},{"location":"/docs/index-claat.html#","text":"Now that we have most of the UI ready, it’s time to start hooking up the code to make everything work. Like the rest of the app shell, be conscious about what code is necessary as part of the key experience and what can be loaded later.\nYour work directory also already includes the app code (scripts/app.js), in it you’ll find:\nAn app object that contains some of the key information necessary for the app. The event listeners for all of the buttons in the header (add/refresh) and in the add city dialog (add/cancel). A method to add or update forecast cards (app.updateForecastCard). A method to get the latest weather forecast data from the Firebase Public Weather API (app.getForecast). A method to iterate the current cards and call app.getForecast to get the latest forecast data (app.updateForecasts). Some fake data (initialWeatherForecast) you can use to quickly test how things render.","title":"Check out the key JavaScript app code"},{"location":"/docs/index-claat.html#","text":"Now that you’ve got the core HTML, styles and JavaScript, it’s time to test the app.\nTo see how the fake weather data is rendered, uncomment the following line at the bottom of your index.html file:\n<!--<script src=\"scripts/app.js\" async></script>-->\nNext, uncomment the following line at the bottom of your app.js file:\n// app.updateForecastCard(initialWeatherForecast);\nReload your app. The result should be a nicely formatted (though fake, as you can tell by the date) forecast card with the spinner disabled, like this:\n[](https://weather-pwa-sample.firebaseapp.com/step-04/)\nOnce you’ve tried it and verified it works as expected, you can remove the call to app.updateForecastCard with the fake data again. We only needed it to ensure that everything worked as expected.","title":"Test it out"},{"location":"/docs/index-claat.html#start-with-a-fast-first-load","text":"Progressive Web Apps should start fast and be usable immediately. In its current state, our Weather App starts quickly, but it’s not useable. There’s no data. We could make an AJAX request to get that data, but that results in an extra request and makes the initial load longer. Instead, provide real data in the first load.","title":"Start with a fast first load"},{"location":"/docs/index-claat.html#","text":"For this code lab, we’ll simulate the server injecting the weather forecast directly into the JavaScript, but in a production app, the latest weather forecast data would be injected by the server based on the IP address geo-location of the user.\nThe code already contains the data that we’re going to inject. It’s the initialWeatherForecast that we used in the previous step.","title":"Inject the weather forecast data"},{"location":"/docs/index-claat.html#","text":"But, how do we know when to display this information, which may not be relevant on future loads when the weather app is pulled from the cache? When the user loads the app on subsequent visits, they may have changed cities, so we need to load the information for those cities, not necessarily the first city they ever looked up.\nUser preferences, like the list of cities a user has subscribed to, should be stored locally using IndexedDB or another fast storage mechanism. To simplify this code lab as much as possible, we’ve used localStorage, which is not ideal for production apps because it is a blocking, synchronous storage mechanism that is potentially very slow on some devices.\n**Extra Credit**: Replace `localStorage` implementation with [idb](https://www.npmjs.com/package/idb), check out [localForage](https://github.com/localForage/localForage) as a simple wrapper to idb.\nFirst, let’s add the code required to save user preferences. Find the following TODO comment in your code.\n// TODO add saveSelectedCities function here\nAnd add the following code below the comment.\n// Save list of cities to localStorage.\n  app.saveSelectedCities = function() {\n    var selectedCities = JSON.stringify(app.selectedCities);\n    localStorage.selectedCities = selectedCities;\n  };\nNext, let’s add the startup code to check if the user has any saved cities and render those, or use the injected data. Find the following comment:\n// TODO add startup code here\nAnd add the following code below this comment:\n/************************************************************************\n   *\n   * Code required to start the app\n   *\n   * NOTE: To simplify this codelab, we've used localStorage.\n   *   localStorage is a synchronous API and has serious performance\n   *   implications. It should not be used in production applications!\n   *   Instead, check out IDB (https://www.npmjs.com/package/idb) or\n   *   SimpleDB (https://gist.github.com/inexorabletash/c8069c042b734519680c)\n   ************************************************************************/\n\n  app.selectedCities = localStorage.selectedCities;\n  if (app.selectedCities) {\n    app.selectedCities = JSON.parse(app.selectedCities);\n    app.selectedCities.forEach(function(city) {\n      app.getForecast(city.key, city.label);\n    });\n  } else {\n    /* The user is using the app for the first time, or the user has not\n     * saved any cities, so show the user some fake data. A real app in this\n     * scenario could guess the user's location via IP lookup and then inject\n     * that data into the page.\n     */\n    app.updateForecastCard(initialWeatherForecast);\n    app.selectedCities = [\n      {key: initialWeatherForecast.key, label: initialWeatherForecast.label}\n    ];\n    app.saveSelectedCities();\n  }\nThe startup code checks if there are any cities saved in local storage. If so, then it parses the local storage data and then displays a forecast card for each of the saved cities. Else, the startup code just uses the fake forecast data and saves that as the default city.","title":"Differentiating the first run"},{"location":"/docs/index-claat.html#","text":"Finally, you need to modify the “add city” button handler to save the selected city to local storage.\nUpdate your butAddCity click handler so that it matches the following code:\ndocument.getElementById('butAddCity').addEventListener('click', function() {\n    // Add the newly selected city\n    var select = document.getElementById('selectCityToAdd');\n    var selected = select.options[select.selectedIndex];\n    var key = selected.value;\n    var label = selected.textContent;\n    if (!app.selectedCities) {\n      app.selectedCities = [];\n    }\n    app.getForecast(key, label);\n    app.selectedCities.push({key: key, label: label});\n    app.saveSelectedCities();\n    app.toggleAddDialog(false);\n  });\nThe new additions are the initialization of app.selectedCities if it doesn’t exist, and the calls to app.selectedCities.push() and app.saveSelectedCities().","title":"Save the selected cities"},{"location":"/docs/index-claat.html#","text":"When first run, your app should immediately show the user the forecast from initialWeatherForecast. Add a new city (by clicking the + icon on the upper right) and verify that two cards are shown. Refresh the browser and verify that the app loads both forecasts and shows the latest information.\n[](https://weather-pwa-sample.firebaseapp.com/step-05/)","title":"Test it out"},{"location":"/docs/index-claat.html#use-service-workers-to-pre-cache-the-app-shell","text":"Progressive Web Apps have to be fast, and installable, which means that they work online, offline, and on intermittent, slow connections. To achieve this, we need to cache our app shell using service worker, so that it’s always available quickly and reliably.\nIf you’re unfamiliar with service workers, you can get a basic understanding by reading Introduction To Service Workers about what they can do, how their lifecycle works and more. Once you’ve completed this code lab, be sure to check out the Debugging Service Workers code lab for a more in-depth look at how to work with service workers.\nFeatures provided via service workers should be considered a progressive enhancement, and added only if supported by the browser. For example, with service workers you can cache the app shell and data for your app, so that it’s available even when the network isn’t. When service workers aren’t supported, the offline code isn’t called, and the user gets a basic experience. Using feature detection to provide progressive enhancement has little overhead and it won’t break in older browsers that don’t support that feature.\n**Remember**: Service worker functionality is only available on pages that are accessed via HTTPS (http://localhost and equivalents will also work, to facilitate testing). To learn about the rationale behind this restriction check out [Prefer Secure Origins For Powerful New Features](http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features) from the Chromium team.","title":"Use service workers to pre-cache the App Shell"},{"location":"/docs/index-claat.html#","text":"The first step to making the app work offline is to register a service worker, a script that allows background functionality without the need for an open web page or user interaction.\nThis takes two simple steps:\nTell the browser to register the JavaScript file as the service worker. Create a JavaScript file containing the service worker.\nFirst, we need to check if the browser supports service workers, and if it does, register the service worker. Add the following code to app.js (after the // TODO add service worker code here comment):\nif ('serviceWorker' in navigator) {\n    navigator.serviceWorker\n             .register('../service-worker.js')\n             .then(function() { console.log('Service Worker Registered'); });\n  }","title":"Register the service worker if it’s available"},{"location":"/docs/index-claat.html#","text":"When the service worker is registered, an install event is triggered the first time the user visits the page. In this event handler, we will cache all the assets that are needed for the application.\nThe code below must NOT be used in production, it covers only the most basic use cases and it's easy to get yourself into a state where your app shell will never update. Be sure to review the section below that discusses the pitfalls of this implementation and how to avoid them.\nWhen the service worker is fired, it should open the caches object and populate it with the assets necessary to load the App Shell. Create a file called service-worker.js in your application root folder (which should be your-first-pwapp-master/work directory). This file must live in the application root because the scope for service workers is defined by the directory in which the file resides. Add this code to your new service-worker.js file:\nvar cacheName = 'weatherPWA-step-6-1';\nvar filesToCache = [];\n\nself.addEventListener('install', function(e) {\n  console.log('[ServiceWorker] Install');\n  e.waitUntil(\n    caches.open(cacheName).then(function(cache) {\n      console.log('[ServiceWorker] Caching app shell');\n      return cache.addAll(filesToCache);\n    })\n  );\n});\nFirst, we need to open the cache with caches.open() and provide a cache name. Providing a cache name allows us to version files, or separate data from the app shell so that we can easily update one but not affect the other.\nOnce the cache is open, we can then call cache.addAll(), which takes a list of URLs, then fetches them from the server and adds the response to the cache. Unfortunately, cache.addAll() is atomic, if any of the files fail, the entire cache step fails!\nAlright, let’s start getting familiar with how you can use DevTools to understand and debug service workers. Before reloading your page, open up DevTools, go the Service Worker pane on the Application panel. It should look like this.\nWhen you see a blank page like this, it means that the currently open page does not have any registered service workers.\nNow, reload your page. The Service Worker pane should now look like this.\nWhen you see information like this, it means the page has a service worker running.\nOK, now we’re are going to take a brief detour and demonstrate a gotcha that you may encounter when developing service workers. To demonstrate, let’s add an activate event listener below the install event listener in your service-worker.js file.\nself.addEventListener('activate', function(e) {\n  console.log('[ServiceWorker] Activate');\n});\nThe activate event is fired when the service worker starts up.\nOpen up the DevTools Console and reload the page, switch to the Service Worker pane in the Application panel and click inspect on the activated service worker. You expect to see the [ServiceWorker] Activate message logged to the console, but it didn’t happen. Check out your Service Worker pane and you can see that the new service worker (that includes the activate event listener) appears to be in a “waiting” state.\nBasically, the old service worker continues to control the page as long as there is a tab open to the page. So, you could close and re-open the page or press the skipWaiting button, but a longer-term solution is to just enable the Update on Reload checkbox on the Service Worker pane of DevTools. When this checkbox is enabled, the service worker is forcibly updated every time that the page reloads.\nEnable the Update on Reload checkbox now and reload the page to confirm that the new service worker gets activated.\nNote: You may see an error in the Service Worker pane of the Application panel similar to the one below, it’s safe to ignore this error.\nThat’s all for now regarding inspecting and debugging service workers in DevTools. We’ll show you some more tricks later. Let’s get back to building your app.\nLet’s expand on the activate event listener to include some logic to update the cache. Update your code to match the code below.\nself.addEventListener('activate', function(e) {\n  console.log('[ServiceWorker] Activate');\n  e.waitUntil(\n    caches.keys().then(function(keyList) {\n      return Promise.all(keyList.map(function(key) {\n        if (key !== cacheName) {\n          console.log('[ServiceWorker] Removing old cache', key);\n          return caches.delete(key);\n        }\n      }));\n    })\n  );\n  return self.clients.claim();\n});\nThis code ensures that your service worker updates its cache whenever any of the app shell files change. In order for this to work, you’d need to increment the cacheName variable at the top of your service worker file.\nThe last statement fixes a corner-case which you can read about in the (optional) information box below.\nWhen the app is complete, `self.clients.claim()` fixes a corner case in which the app wasn't returning the latest data. You can reproduce the corner case by commenting out the line below and then doing the following steps: 1) load app for first time so that the initial New York City data is shown 2) press the refresh button on the app 3) go offline 4) reload the app. You expect to see the newer NYC data, but you actually see the initial data. This happens because the service worker is not yet activated. `self.clients.claim()` essentially lets you activate the service worker faster.\nFinally, let’s update the list of files required for the app shell. In the array, we need to include all of the files our app needs, including images, JavaScript, stylesheets, etc. Near the top of your service-worker.js file, replace var filesToCache = []; with the code below:\nvar filesToCache = [\n  '/',\n  '/index.html',\n  '/scripts/app.js',\n  '/styles/inline.css',\n  '/images/clear.png',\n  '/images/cloudy-scattered-showers.png',\n  '/images/cloudy.png',\n  '/images/fog.png',\n  '/images/ic_add_white_24px.svg',\n  '/images/ic_refresh_white_24px.svg',\n  '/images/partly-cloudy.png',\n  '/images/rain.png',\n  '/images/scattered-showers.png',\n  '/images/sleet.png',\n  '/images/snow.png',\n  '/images/thunderstorm.png',\n  '/images/wind.png'\n];\nBe sure to include all permutations of file names, for example our app is served from `index.html`, but it may also be requested as `/` since the server sends `index.html` when a root folder is requested. You could deal with this in the `fetch` method, but it would require special casing which may become complex.\nOur app doesn’t work offline quite yet. We’ve cached the app shell components, but we still need to load them from the local cache.","title":"Cache the site assets"},{"location":"/docs/index-claat.html#","text":"Service workers provide the ability to intercept requests made from our Progressive Web App and handle them within the service worker. That means we can determine how we want to handle the request and potentially serve our own cached response.\nFor example:\nself.addEventListener('fetch', function(e) {\n  // Do something interesting with the fetch here\n});\nLet’s now serve the app shell from the cache. Add the following code to the bottom of your service-worker.js file:\nself.addEventListener('fetch', function(e) {\n  console.log('[ServiceWorker] Fetch', e.request.url);\n  e.respondWith(\n    caches.match(e.request).then(function(response) {\n      return response || fetch(e.request);\n    })\n  );\n});\nStepping from inside, out, caches.match() evaluates the web request that triggered the fetch event, and checks to see if it’s available in the cache. It then either responds with the cached version, or uses fetch to get a copy from the network. The response is passed back to the web page with e.respondWith().\nIf you're not seeing the `[ServiceWorker]` logging in the console, be sure you've changed the `cacheName` variable and that you're inspecting the right service worker by opening the Service Worker pane in the Applications panel and clicking **inspect** on the running service worker. If that doesn't work, see the section on Tips for testing live service workers.","title":"Serve the app shell from the cache"},{"location":"/docs/index-claat.html#test-it-out","text":"Your app is now offline-capable! Let’s try it out.\nReload your page and then go to the Cache Storage pane on the Application panel of DevTools. Right click Cache Storage, pick Refresh Caches, expand the section and you should see the name of your app shell cache listed on the left-hand side. When you click on your app shell cache you can see all of the resources that it has currently cached.\nNow, let’s test out offline mode. Go back to the Service Worker pane of DevTools and enable the Offline checkbox. After enabling it, you should see a little yellow warning icon next to the Network panel tab. This indicates that you’re offline.\nReload your page and… it works! Kind of, at least. Notice how it loads the initial (fake) weather data.\nCheck out the else clause in app.getForecast() to understand why the app is able to load the fake data.\nThe next step is to modify the app and service worker logic to be able to cache weather data, and return the most recent data from the cache when the app is offline.\nTip: To start fresh and clear all saved data (localStorage, indexedDB data, cached files) and remove any service workers, use the Clear storage pane in the Application tab.\n[](https://weather-pwa-sample.firebaseapp.com/step-06/)","title":"Test it out"},{"location":"/docs/index-claat.html#","text":"As previously mentioned, this code must not be used in production because of the many unhandled edge cases.","title":"Beware of the edge cases"},{"location":"/docs/index-claat.html#","text":"For example this caching method requires you to update the cache key every time content is changed, otherwise, the cache will not be updated, and the old content will be served. So be sure to change the cache key with every change as you’re working on your project!","title":"Cache depends on updating the cache key for every change"},{"location":"/docs/index-claat.html#","text":"Another downside is that the entire cache is invalidated and needs to be re-downloaded every time a file changes. That means fixing a simple single character spelling mistake will invalidate the cache and require everything to be downloaded again. Not exactly efficient.","title":"Requires everything to be redownloaded for every change"},{"location":"/docs/index-claat.html#","text":"There’s another important caveat here. It’s crucial that the HTTPS request made during the install handler goes directly to the network and doesn’t return a response from the browser’s cache. Otherwise the browser may return the old, cached version, resulting in the service worker cache never actually updating!","title":"Browser cache may prevent the service worker cache from updating"},{"location":"/docs/index-claat.html#","text":"Our app uses a cache-first strategy, which results in a copy of any cached content being returned without consulting the network. While a cache-first strategy is easy to implement, it can cause challenges in the future. Once the copy of the host page and service worker registration is cached, it can be extremely difficult to change the configuration of the service worker (since the configuration depends on where it was defined), and you could find yourself deploying sites that are extremely difficult to update!","title":"Beware of cache-first strategies in production"},{"location":"/docs/index-claat.html#","text":"So how do we avoid these edge cases? Use a library like Workbox, which provides fine control over what gets expired, ensures requests go directly to the network and handles all of the hard work for you.","title":"How do I avoid these edge cases?"},{"location":"/docs/index-claat.html#","text":"Debugging service workers can be a challenge, and when it involves caching, things can become even more of a nightmare if the cache isn’t updated when you expect it. Between the typical service worker life cycle and bug in your code, you may become quickly frustrated. But don’t. There are some tools you can use to make your life easier.","title":"Tips for testing live service workers"},{"location":"/docs/index-claat.html#","text":"In some cases, you may find yourself loading cached data or that things aren’t updated as you expect. To clear all saved data (localStorage, indexedDB data, cached files) and remove any service workers, use the Clear storage pane in the Application tab.\nSome other tips:\nOnce a service worker has been unregistered, it may remain listed until its containing browser window is closed. If multiple windows to your app are open, the new service worker will not take effect until they’ve all been reloaded and updated to the latest service worker. Unregistering a service worker does not clear the cache, so it may be possible you’ll still get old data if the cache name hasn’t changed. If a service worker exists and a new service worker is registered, the new service worker won’t take control until the page is reloaded, unless you take immediate control.","title":"Start Fresh"},{"location":"/docs/index-claat.html#use-service-workers-to-cache-the-forecast-data","text":"Choosing the right caching strategy for your data is vital and depends on the type of data your app presents. For example, time-sensitive data like weather or stock quotes should be as fresh as possible, while avatar images or article content can be updated less frequently.\nThe cache-first-then-network strategy is ideal for our app. It gets data on screen as quickly as possible, then updates that once the network has returned the latest data. In comparison to network-first-then-cache, the user does not have to wait until the fetch times out to get the cached data.\nCache-first-then-network means we need to kick off two asynchronous requests, one to the cache and one to the network. Our network request with the app doesn’t need to change much, but we need to modify the service worker to cache the response before returning it.\nUnder normal circumstances, the cached data will be returned almost immediately providing the app with recent data it can use. Then, when the network request returns, the app will be updated using the latest data from the network.","title":"Use service workers to cache the forecast data"},{"location":"/docs/index-claat.html#","text":"We need to modify the service worker to intercept requests to the weather API and store their responses in the cache, so we can easily access them later. In the cache-then-network strategy, we expect the network response to be the ‘source of truth’, always providing us with the most recent information. If it can’t, it’s OK to fail because we’ve already retrieved the latest cached data in our app.\nIn the service worker, let’s add a dataCacheName so that we can separate our applications data from the app shell. When the app shell is updated and older caches are purged, our data will remain untouched, ready for a super fast load. Keep in mind, if your data format changes in the future, you’ll need a way to handle that and ensure the app shell and content stay in sync.\nAdd the following line to the top of your service-worker.js file:\nvar dataCacheName = 'weatherData-v1';\nNext, update the activate event handler so that it doesn’t delete the data cache when it cleans up the app shell cache.\nif (key !== cacheName && key !== dataCacheName) {\nFinally, update the fetch event handler to handle requests to the data API separately from other requests.\nself.addEventListener('fetch', function(e) {\n  console.log('[Service Worker] Fetch', e.request.url);\n  var dataUrl = 'https://query.yahooapis.com/v1/public/yql';\n  if (e.request.url.indexOf(dataUrl) > -1) {\n    /*\n     * When the request URL contains dataUrl, the app is asking for fresh\n     * weather data. In this case, the service worker always goes to the\n     * network and then caches the response. This is called the \"Cache then\n     * network\" strategy:\n     * https://jakearchibald.com/2014/offline-cookbook/#cache-then-network\n     */\n    e.respondWith(\n      caches.open(dataCacheName).then(function(cache) {\n        return fetch(e.request).then(function(response){\n          cache.put(e.request.url, response.clone());\n          return response;\n        });\n      })\n    );\n  } else {\n    /*\n     * The app is asking for app shell files. In this scenario the app uses the\n     * \"Cache, falling back to the network\" offline strategy:\n     * https://jakearchibald.com/2014/offline-cookbook/#cache-falling-back-to-network\n     */\n    e.respondWith(\n      caches.match(e.request).then(function(response) {\n        return response || fetch(e.request);\n      })\n    );\n  }\n});\nThe code intercepts the request and checks if the URL starts with the address of the weather API. If it does we’ll use fetch to make the request. Once the response is returned, our code opens the cache, clones the response, stores it in the cache, and finally returns the response to the original requestor.\nOur app won’t work offline quite yet. We’ve implemented caching and retrieval for the app shell, but even though we’re caching the data, the app doesn’t yet check the cache to see if it has any weather data.","title":"Intercept the network request and cache the response"},{"location":"/docs/index-claat.html#","text":"As mentioned previously, the app needs to kick off two asynchronous requests, one to the cache and one to the network. The app uses the caches object available in window to access the cache and retrieve the latest data. This is an excellent example of progressive enhancement as the caches object may not be available in all browsers, and if it’s not the network request should still work.\nTo do this, we need to:\nCheck if the caches object is available in the global window object. Request data from the cache.\nIf the server request is still outstanding, update the app with the cached data.\nRequest data from the server.\nSave the data for quick access later. Update the app with the fresh data from the server.","title":"Making the requests"},{"location":"/docs/index-claat.html#","text":"Next, we need to check if the caches object exists and request the latest data from it. Find the TODO add cache logic here comment in app.getForecast(), and then add the code below under the comment.\nif ('caches' in window) {\n      /*\n       * Check if the service worker has already cached this city's weather\n       * data. If the service worker has the data, then display the cached\n       * data while the app fetches the latest data.\n       */\n      caches.match(url).then(function(response) {\n        if (response) {\n          response.json().then(function updateFromCache(json) {\n            var results = json.query.results;\n            results.key = key;\n            results.label = label;\n            results.created = json.query.created;\n            app.updateForecastCard(results);\n          });\n        }\n      });\n    }\nOur weather app now makes two asynchronous requests for data, one from the cache and one via an XHR. If there’s data in the cache, it’ll be returned and rendered extremely quickly (tens of milliseconds) and update the card only if the XHR is still outstanding. Then, when the XHR responds, the card will be updated with the freshest data direct from the weather API.\nNotice how the cache request and the XHR request both end with a call to update the forecast card. How does the app know whether it’s displaying the latest data? This is handled in the following code from app.updateForecastCard:\nvar cardLastUpdatedElem = card.querySelector('.card-last-updated');\n    var cardLastUpdated = cardLastUpdatedElem.textContent;\n    if (cardLastUpdated) {\n      cardLastUpdated = new Date(cardLastUpdated);\n      // Bail if the card has more recent data then the data\n      if (dataLastUpdated.getTime() < cardLastUpdated.getTime()) {\n        return;\n      }\n    }\nEvery time that a card is updated, the app stores the timestamp of the data on a hidden attribute on the card. The app just bails if the timestamp that already exists on the card is newer than the data that was passed to the function.","title":"Get data from the cache"},{"location":"/docs/index-claat.html#","text":"The app should be completely offline-functional now. Save a couple of cities and press the refresh button on the app to get fresh weather data, and then go offline and reload the page.\nThen go to the Cache Storage pane on the Application panel of DevTools. Expand the section and you should see the name of your app shell and data cache listed on the left-hand side. Opening the data cache should should the data stored for each city.\n[](https://weather-pwa-sample.firebaseapp.com/step-07/)","title":"Test it out"},{"location":"/docs/index-claat.html#support-native-integration","text":"Nobody likes to have to type in long URLs on a mobile keyboard if they don’t need to. With the Add To home screen feature, your users can choose to add a shortcut link to their device just as they would install a native app from a store, but with a lot less friction.","title":"Support native integration"},{"location":"/docs/index-claat.html#","text":"Web app install banners give you the ability to let your users quickly and seamlessly add your web app to their home screen, making it easy to launch and return to your app. Adding app install banners is easy, and Chrome handles most of the heavy lifting for you. We simply need to include a web app manifest file with details about the app.\nChrome then uses a set of criteria including the use of a service worker, SSL status and visit frequency heuristics to determine when to show the banner. In addition a user can manually add it via the “Add to Home Screen” menu button in Chrome.","title":"Web App Install Banners and Add to Homescreen for Chrome on Android"},{"location":"/docs/index-claat.html#","text":"The web app manifest is a simple JSON file that gives you, the developer, the ability to control how your app appears to the user in the areas that they would expect to see apps (for example the mobile home screen), direct what the user can launch and more importantly how they can launch it.\nUsing the web app manifest, your web app can:\nHave a rich presence on the user’s Android home screen Be launched in full-screen mode on Android with no URL bar Control the screen orientation for optimal viewing Define a “splash screen” launch experience and theme color for the site Track whether you’re launched from the home screen or URL bar\nCreate a file named manifest.json in your work folder and copy/paste the following contents:\n{\n  \"name\": \"Weather\",\n  \"short_name\": \"Weather\",\n  \"icons\": [{\n    \"src\": \"images/icons/icon-128x128.png\",\n      \"sizes\": \"128x128\",\n      \"type\": \"image/png\"\n    }, {\n      \"src\": \"images/icons/icon-144x144.png\",\n      \"sizes\": \"144x144\",\n      \"type\": \"image/png\"\n    }, {\n      \"src\": \"images/icons/icon-152x152.png\",\n      \"sizes\": \"152x152\",\n      \"type\": \"image/png\"\n    }, {\n      \"src\": \"images/icons/icon-192x192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\"\n    }, {\n      \"src\": \"images/icons/icon-256x256.png\",\n      \"sizes\": \"256x256\",\n      \"type\": \"image/png\"\n    }],\n  \"start_url\": \"/index.html\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#3E4EB8\",\n  \"theme_color\": \"#2F3BA2\"\n}\nThe manifest supports an array of icons, intended for different screen sizes. At the time of this writing, Chrome and Opera Mobile, the only browsers that support web app manifests, won’t use anything smaller than 192px.\nAn easy way to track how the app is launched is to add a query string to the start_url parameter and then use an analytics suite to track the query string. If you use this method, remember to update the list of files cached by the App Shell to ensure that the file with the query string is cached.","title":"Declare an app manifest with a manifest.json file"},{"location":"/docs/index-claat.html#","text":"Now add the following line to the bottom of the <head> element in your index.html file:\n<link rel=\"manifest\" href=\"/manifest.json\">","title":"Tell the browser about your manifest file"},{"location":"/docs/index-claat.html#","text":"Place the manifest link on all your site’s pages, so it will be retrieved by Chrome right when the user first visits, no matter what page they land on. The short_name is preferred on Chrome and will be used if present over the name field. Define icon sets for different density screens. Chrome will attempt to use the icon closest to 48dp, for example, 96px on a 2x device or 144px for a 3x device. Remember to include an icon with a size that is sensible for a splash screen and don’t forget to set the background_color.\nFurther Reading:\nUsing app install banners","title":"Best Practices"},{"location":"/docs/index-claat.html#","text":"In your index.html, add the following to the bottom of the <head> element:\n<!-- Add to home screen for Safari on iOS -->\n  <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n  <meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\">\n  <meta name=\"apple-mobile-web-app-title\" content=\"Weather PWA\">\n  <link rel=\"apple-touch-icon\" href=\"images/icons/icon-152x152.png\">","title":"Add to Homescreen elements for Safari on iOS"},{"location":"/docs/index-claat.html#","text":"In your index.html, add the following to the bottom of the <head> element:\n<meta name=\"msapplication-TileImage\" content=\"images/icons/icon-144x144.png\">\n  <meta name=\"msapplication-TileColor\" content=\"#2F3BA2\">","title":"Tile Icon for Windows"},{"location":"/docs/index-claat.html#","text":"In this section we’ll show you a couple of ways to test your web app manifest.\nThe first way is DevTools. Open up the Manifest pane on the Application panel. If you’ve added the manifest information correctly, you’ll be able to see it parsed and displayed in a human-friendly format on this pane.\nYou can also test the add to homescreen feature from this pane. Click on the Add to homescreen button. You should see a “add this site to your shelf” message below your URL bar, like in the screenshot below.\nThis is the desktop equivalent of mobile’s add to homescreen feature. If you can successfully trigger this prompt on desktop, then you can be assured that mobile users can add your app to their devices.\nThe second way to test is via Web Server for Chrome. With this approach, you expose your local development server (on your desktop or laptop) to other computers, and then you just access your progressive web app from a real mobile device.\nOpening up a port for remote access is handy for testing this step but may be blocked by your computer's firewall rules or network administrator. Opening ports for remote access is generally not a good thing to leave running on your computer. So, for security reasons, when you've completed testing this step, disable the `Accessible on local network` option and restart your web server.\nOn Web Server for Chrome configuration dialog, select the Accessible on local network option:\nToggle the Web Server to STOPPED and back to STARTED. You’ll see a new URL which can be used to access your app remotely.\nNow, access your site from a mobile device, using the new URL.\nYou will see service worker errors in the console when testing this way because the service worker is not being served over HTTPS.\nUsing Chrome from an Android device, try adding the app to the homescreen and verifying that the launch screen appears properly and the right icons are used.\nOn Safari and Internet Explorer, you can also manually add the app to your homescreen.\n[](https://weather-pwa-sample.firebaseapp.com/step-08/)","title":"Test it out"},{"location":"/docs/index-claat.html#deploy-to-a-secure-host-and-celebrate","text":"The final step is to deploy our weather app to a server that supports HTTPS. If you don’t already have one, the absolute easiest (and free) approach is to use the static content hosting from Firebase. It’s super easy to use, serves content over HTTPS and is backed by a global CDN.","title":"Deploy to a secure host and celebrate"},{"location":"/docs/index-claat.html#","text":"There’s one more thing that you should consider, minifying the key styles and inlining them directly into index.html. Page Speed Insights recommends serving the above the fold content in the first 15k bytes of the request.\nSee how small you can get the initial request with everything inlined.\nFurther Reading: PageSpeed Insight Rules\nThis step requires you to have [Node & NPM](https://docs.npmjs.com/getting-started/installing-node) installed on your system. If it's not, you can use any other hosting provider that supports HTTP**S**. We've used Firebase because it automatically redirects users from HTTP to HTTP**S**. If you use a different provider, be sure they're always redirects to HTTP**S**.","title":"Extra credit: minify and inline CSS"},{"location":"/docs/index-claat.html#","text":"If you’re new to Firebase, you’ll need to create your account and install some tools first.\nCreate a Firebase account at https://firebase.google.com/console/ Install the Firebase tools via npm: npm install -g firebase-tools\nOnce your account has been created and you’ve signed in, you’re ready to deploy!\nCreate a new app at https://firebase.google.com/console/ If you haven’t recently signed in to the Firebase tools, update your credentials: firebase login Initialize your app, and provide the directory (likely work) where your completed app lives: firebase init Finally, deploy the app to Firebase: firebase deploy Celebrate. You’re done! Your app will be deployed to the domain: https://YOUR-FIREBASE-APP.firebaseapp.com\nFurther reading: Firebase Hosting Guide","title":"Deploy to Firebase"},{"location":"/docs/index-claat.html#","text":"Try adding the app to your home screen then disconnect the network and verify the app works offline as expected.\n[](https://weather-pwa-sample.firebaseapp.com/final/)","title":"Test it out"},{"location":"/docs/tools/index.html","text":"","title":"Software and Tools"},{"location":"/docs/tools/index.html#software-and-tools","text":"","title":"Software and Tools"},{"location":"/docs/publication/index.html","text":"","title":"Publications"},{"location":"/docs/publication/index.html#publications","text":"","title":"Publications"}]}